"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PreviewPane = void 0;

var _styledBase = _interopRequireDefault(require("@emotion/styled-base"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _immutable = require("immutable");

var _reactImmutableProptypes = _interopRequireDefault(require("react-immutable-proptypes"));

var _reactFrameComponent = _interopRequireWildcard(require("react-frame-component"));

var _netlifyCmsUiDefault = require("netlify-cms-ui-default");

var _registry = require("../../../lib/registry");

var _UI = require("../../UI");

var _collections = require("../../../reducers/collections");

var _reactRedux = require("react-redux");

var _media = require("../../../actions/media");

var _medias = require("../../../reducers/medias");

var _fieldInference = require("../../../constants/fieldInference");

var _EditorPreviewContent = _interopRequireDefault(require("./EditorPreviewContent.js"));

var _PreviewHOC = _interopRequireDefault(require("./PreviewHOC"));

var _EditorPreview = _interopRequireDefault(require("./EditorPreview"));

var _core = require("@emotion/core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const PreviewPaneFrame = ( /*#__PURE__*/0, _styledBase.default)(_reactFrameComponent.default, {
  target: "e6emspu0",
  label: "PreviewPaneFrame"
})("width:100%;height:100%;border:none;background:#fff;border-radius:", _netlifyCmsUiDefault.lengths.borderRadius, ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRvci9FZGl0b3JQcmV2aWV3UGFuZS9FZGl0b3JQcmV2aWV3UGFuZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQnNDIiwiZmlsZSI6Ii4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRvci9FZGl0b3JQcmV2aWV3UGFuZS9FZGl0b3JQcmV2aWV3UGFuZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdAZW1vdGlvbi9zdHlsZWQnO1xuaW1wb3J0IHsgTGlzdCwgTWFwIH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBJbW11dGFibGVQcm9wVHlwZXMgZnJvbSAncmVhY3QtaW1tdXRhYmxlLXByb3B0eXBlcyc7XG5pbXBvcnQgRnJhbWUsIHsgRnJhbWVDb250ZXh0Q29uc3VtZXIgfSBmcm9tICdyZWFjdC1mcmFtZS1jb21wb25lbnQnO1xuaW1wb3J0IHsgbGVuZ3RocyB9IGZyb20gJ25ldGxpZnktY21zLXVpLWRlZmF1bHQnO1xuaW1wb3J0IHsgcmVzb2x2ZVdpZGdldCwgZ2V0UHJldmlld1RlbXBsYXRlLCBnZXRQcmV2aWV3U3R5bGVzIH0gZnJvbSAnTGliL3JlZ2lzdHJ5JztcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICdVSSc7XG5pbXBvcnQgeyBzZWxlY3RUZW1wbGF0ZU5hbWUsIHNlbGVjdEluZmVyZWRGaWVsZCwgc2VsZWN0RmllbGQgfSBmcm9tICdSZWR1Y2Vycy9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYm91bmRHZXRBc3NldCB9IGZyb20gJ0FjdGlvbnMvbWVkaWEnO1xuaW1wb3J0IHsgc2VsZWN0SXNMb2FkaW5nQXNzZXQgfSBmcm9tICdSZWR1Y2Vycy9tZWRpYXMnO1xuaW1wb3J0IHsgSU5GRVJBQkxFX0ZJRUxEUyB9IGZyb20gJ0NvbnN0YW50cy9maWVsZEluZmVyZW5jZSc7XG5pbXBvcnQgRWRpdG9yUHJldmlld0NvbnRlbnQgZnJvbSAnLi9FZGl0b3JQcmV2aWV3Q29udGVudC5qcyc7XG5pbXBvcnQgUHJldmlld0hPQyBmcm9tICcuL1ByZXZpZXdIT0MnO1xuaW1wb3J0IEVkaXRvclByZXZpZXcgZnJvbSAnLi9FZGl0b3JQcmV2aWV3JztcblxuY29uc3QgUHJldmlld1BhbmVGcmFtZSA9IHN0eWxlZChGcmFtZSlgXG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJvcmRlcjogbm9uZTtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm9yZGVyLXJhZGl1czogJHtsZW5ndGhzLmJvcmRlclJhZGl1c307XG5gO1xuXG5leHBvcnQgY2xhc3MgUHJldmlld1BhbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBnZXRXaWRnZXQgPSAoZmllbGQsIHZhbHVlLCBtZXRhZGF0YSwgcHJvcHMsIGlkeCA9IG51bGwpID0+IHtcbiAgICBjb25zdCB7IGdldEFzc2V0LCBlbnRyeSB9ID0gcHJvcHM7XG4gICAgY29uc3Qgd2lkZ2V0ID0gcmVzb2x2ZVdpZGdldChmaWVsZC5nZXQoJ3dpZGdldCcpKTtcbiAgICBjb25zdCBrZXkgPSBpZHggPyBmaWVsZC5nZXQoJ25hbWUnKSArICdfJyArIGlkeCA6IGZpZWxkLmdldCgnbmFtZScpO1xuICAgIGNvbnN0IHZhbHVlSXNJbk1hcCA9IHZhbHVlICYmICF3aWRnZXQuYWxsb3dNYXBWYWx1ZSAmJiBNYXAuaXNNYXAodmFsdWUpO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGFuIEhPQyB0byBwcm92aWRlIGNvbmRpdGlvbmFsIHVwZGF0ZXMgZm9yIGFsbCBwcmV2aWV3cy5cbiAgICAgKi9cbiAgICByZXR1cm4gIXdpZGdldC5wcmV2aWV3ID8gbnVsbCA6IChcbiAgICAgIDxQcmV2aWV3SE9DXG4gICAgICAgIHByZXZpZXdDb21wb25lbnQ9e3dpZGdldC5wcmV2aWV3fVxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgZmllbGQ9e2ZpZWxkfVxuICAgICAgICBnZXRBc3NldD17Z2V0QXNzZXR9XG4gICAgICAgIHZhbHVlPXt2YWx1ZUlzSW5NYXAgPyB2YWx1ZS5nZXQoZmllbGQuZ2V0KCduYW1lJykpIDogdmFsdWV9XG4gICAgICAgIGVudHJ5PXtlbnRyeX1cbiAgICAgICAgZmllbGRzTWV0YURhdGE9e21ldGFkYXRhfVxuICAgICAgICByZXNvbHZlV2lkZ2V0PXtyZXNvbHZlV2lkZ2V0fVxuICAgICAgLz5cbiAgICApO1xuICB9O1xuXG4gIGluZmVyZWRGaWVsZHMgPSB7fTtcblxuICBpbmZlckZpZWxkcygpIHtcbiAgICBjb25zdCB0aXRsZUZpZWxkID0gc2VsZWN0SW5mZXJlZEZpZWxkKHRoaXMucHJvcHMuY29sbGVjdGlvbiwgJ3RpdGxlJyk7XG4gICAgY29uc3Qgc2hvcnRUaXRsZUZpZWxkID0gc2VsZWN0SW5mZXJlZEZpZWxkKHRoaXMucHJvcHMuY29sbGVjdGlvbiwgJ3Nob3J0VGl0bGUnKTtcbiAgICBjb25zdCBhdXRob3JGaWVsZCA9IHNlbGVjdEluZmVyZWRGaWVsZCh0aGlzLnByb3BzLmNvbGxlY3Rpb24sICdhdXRob3InKTtcblxuICAgIHRoaXMuaW5mZXJlZEZpZWxkcyA9IHt9O1xuICAgIGlmICh0aXRsZUZpZWxkKSB0aGlzLmluZmVyZWRGaWVsZHNbdGl0bGVGaWVsZF0gPSBJTkZFUkFCTEVfRklFTERTLnRpdGxlO1xuICAgIGlmIChzaG9ydFRpdGxlRmllbGQpIHRoaXMuaW5mZXJlZEZpZWxkc1tzaG9ydFRpdGxlRmllbGRdID0gSU5GRVJBQkxFX0ZJRUxEUy5zaG9ydFRpdGxlO1xuICAgIGlmIChhdXRob3JGaWVsZCkgdGhpcy5pbmZlcmVkRmllbGRzW2F1dGhvckZpZWxkXSA9IElORkVSQUJMRV9GSUVMRFMuYXV0aG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZGdldCBjb21wb25lbnQgZm9yIGEgbmFtZWQgZmllbGQsIGFuZCBtYWtlcyByZWN1cnNpdmUgY2FsbHNcbiAgICogdG8gcmV0cmlldmUgY29tcG9uZW50cyBmb3IgbmVzdGVkIGFuZCBkZWVwbHkgbmVzdGVkIGZpZWxkcywgd2hpY2ggb2NjdXIgaW5cbiAgICogb2JqZWN0IGFuZCBsaXN0IHR5cGUgZmllbGRzLiBVc2VkIGludGVybmFsbHkgdG8gcmV0cmlldmUgd2lkZ2V0cywgYW5kIGFsc29cbiAgICogZXhwb3NlZCBmb3IgdXNlIGluIGN1c3RvbSBwcmV2aWV3IHRlbXBsYXRlcy5cbiAgICovXG4gIHdpZGdldEZvciA9IChcbiAgICBuYW1lLFxuICAgIGZpZWxkcyA9IHRoaXMucHJvcHMuZmllbGRzLFxuICAgIHZhbHVlcyA9IHRoaXMucHJvcHMuZW50cnkuZ2V0KCdkYXRhJyksXG4gICAgZmllbGRzTWV0YURhdGEgPSB0aGlzLnByb3BzLmZpZWxkc01ldGFEYXRhLFxuICApID0+IHtcbiAgICAvLyBXZSByZXRyaWV2ZSB0aGUgZmllbGQgYnkgbmFtZSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIGFsc28gYmUgdXNlZCBpblxuICAgIC8vIGN1c3RvbSBwcmV2aWV3IHRlbXBsYXRlcywgd2hlcmUgdGhlIGZpZWxkIG9iamVjdCBjYW4ndCBiZSBwYXNzZWQgaW4uXG4gICAgbGV0IGZpZWxkID0gZmllbGRzICYmIGZpZWxkcy5maW5kKGYgPT4gZi5nZXQoJ25hbWUnKSA9PT0gbmFtZSk7XG4gICAgbGV0IHZhbHVlID0gTWFwLmlzTWFwKHZhbHVlcykgJiYgdmFsdWVzLmdldChmaWVsZC5nZXQoJ25hbWUnKSk7XG4gICAgaWYgKGZpZWxkLmdldCgnbWV0YScpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucHJvcHMuZW50cnkuZ2V0SW4oWydtZXRhJywgZmllbGQuZ2V0KCduYW1lJyldKTtcbiAgICB9XG4gICAgY29uc3QgbmVzdGVkRmllbGRzID0gZmllbGQuZ2V0KCdmaWVsZHMnKTtcbiAgICBjb25zdCBzaW5nbGVGaWVsZCA9IGZpZWxkLmdldCgnZmllbGQnKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGZpZWxkc01ldGFEYXRhICYmIGZpZWxkc01ldGFEYXRhLmdldChmaWVsZC5nZXQoJ25hbWUnKSwgTWFwKCkpO1xuXG4gICAgaWYgKG5lc3RlZEZpZWxkcykge1xuICAgICAgZmllbGQgPSBmaWVsZC5zZXQoJ2ZpZWxkcycsIHRoaXMuZ2V0TmVzdGVkV2lkZ2V0cyhuZXN0ZWRGaWVsZHMsIHZhbHVlLCBtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChzaW5nbGVGaWVsZCkge1xuICAgICAgZmllbGQgPSBmaWVsZC5zZXQoJ2ZpZWxkJywgdGhpcy5nZXRTaW5nbGVOZXN0ZWQoc2luZ2xlRmllbGQsIHZhbHVlLCBtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsbGVkV2lkZ2V0cyA9IFsnc3RyaW5nJywgJ3RleHQnLCAnbnVtYmVyJ107XG4gICAgY29uc3QgaW5mZXJlZEZpZWxkID0gT2JqZWN0LmVudHJpZXModGhpcy5pbmZlcmVkRmllbGRzKVxuICAgICAgLmZpbHRlcigoW2tleV0pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGRUb01hdGNoID0gc2VsZWN0RmllbGQodGhpcy5wcm9wcy5jb2xsZWN0aW9uLCBrZXkpO1xuICAgICAgICByZXR1cm4gZmllbGRUb01hdGNoID09PSBmaWVsZDtcbiAgICAgIH0pXG4gICAgICAubWFwKChbLCB2YWx1ZV0pID0+IHZhbHVlKVswXTtcblxuICAgIGlmIChpbmZlcmVkRmllbGQpIHtcbiAgICAgIHZhbHVlID0gaW5mZXJlZEZpZWxkLmRlZmF1bHRQcmV2aWV3KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdmFsdWUgJiZcbiAgICAgIGxhYmVsbGVkV2lkZ2V0cy5pbmRleE9mKGZpZWxkLmdldCgnd2lkZ2V0JykpICE9PSAtMSAmJlxuICAgICAgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPCA1MFxuICAgICkge1xuICAgICAgdmFsdWUgPSAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHN0cm9uZz57ZmllbGQuZ2V0KCdsYWJlbCcsIGZpZWxkLmdldCgnbmFtZScpKX06PC9zdHJvbmc+IHt2YWx1ZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZ2V0V2lkZ2V0KGZpZWxkLCB2YWx1ZSwgbWV0YWRhdGEsIHRoaXMucHJvcHMpIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHdpZGdldHMgZm9yIG5lc3RlZCBmaWVsZHMgKGNoaWxkcmVuIG9mIG9iamVjdC9saXN0IGZpZWxkcylcbiAgICovXG4gIGdldE5lc3RlZFdpZGdldHMgPSAoZmllbGRzLCB2YWx1ZXMsIGZpZWxkc01ldGFEYXRhKSA9PiB7XG4gICAgLy8gRmllbGRzIG5lc3RlZCB3aXRoaW4gYSBsaXN0IGZpZWxkIHdpbGwgYmUgcGFpcmVkIHdpdGggYSBMaXN0IG9mIHZhbHVlIE1hcHMuXG4gICAgaWYgKExpc3QuaXNMaXN0KHZhbHVlcykpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IHRoaXMud2lkZ2V0c0Zvck5lc3RlZEZpZWxkcyhmaWVsZHMsIHZhbHVlLCBmaWVsZHNNZXRhRGF0YSkpO1xuICAgIH1cbiAgICAvLyBGaWVsZHMgbmVzdGVkIHdpdGhpbiBhbiBvYmplY3QgZmllbGQgd2lsbCBiZSBwYWlyZWQgd2l0aCBhIHNpbmdsZSBNYXAgb2YgdmFsdWVzLlxuICAgIHJldHVybiB0aGlzLndpZGdldHNGb3JOZXN0ZWRGaWVsZHMoZmllbGRzLCB2YWx1ZXMsIGZpZWxkc01ldGFEYXRhKTtcbiAgfTtcblxuICBnZXRTaW5nbGVOZXN0ZWQgPSAoZmllbGQsIHZhbHVlcywgZmllbGRzTWV0YURhdGEpID0+IHtcbiAgICBpZiAoTGlzdC5pc0xpc3QodmFsdWVzKSkge1xuICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlLCBpZHgpID0+XG4gICAgICAgIHRoaXMuZ2V0V2lkZ2V0KGZpZWxkLCB2YWx1ZSwgZmllbGRzTWV0YURhdGEuZ2V0KGZpZWxkLmdldCgnbmFtZScpKSwgdGhpcy5wcm9wcywgaWR4KSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFdpZGdldChmaWVsZCwgdmFsdWVzLCBmaWVsZHNNZXRhRGF0YS5nZXQoZmllbGQuZ2V0KCduYW1lJykpLCB0aGlzLnByb3BzKTtcbiAgfTtcblxuICAvKipcbiAgICogVXNlIHdpZGdldEZvciBhcyBhIG1hcHBpbmcgZnVuY3Rpb24gZm9yIHJlY3Vyc2l2ZSB3aWRnZXQgcmV0cmlldmFsXG4gICAqL1xuICB3aWRnZXRzRm9yTmVzdGVkRmllbGRzID0gKGZpZWxkcywgdmFsdWVzLCBmaWVsZHNNZXRhRGF0YSkgPT4ge1xuICAgIHJldHVybiBmaWVsZHMubWFwKGZpZWxkID0+IHRoaXMud2lkZ2V0Rm9yKGZpZWxkLmdldCgnbmFtZScpLCBmaWVsZHMsIHZhbHVlcywgZmllbGRzTWV0YURhdGEpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBleGlzdHMgZW50aXJlbHkgdG8gZXhwb3NlIG5lc3RlZCB3aWRnZXRzIGZvciBvYmplY3QgYW5kIGxpc3RcbiAgICogZmllbGRzIHRvIGN1c3RvbSBwcmV2aWV3IHRlbXBsYXRlcy5cbiAgICpcbiAgICogVE9ETzogc2VlIGlmIHdpZGdldEZvciBjYW4gbm93IHByb3ZpZGUgdGhpcyBmdW5jdGlvbmFsaXR5IGZvciBwcmV2aWV3IHRlbXBsYXRlc1xuICAgKi9cbiAgd2lkZ2V0c0ZvciA9IG5hbWUgPT4ge1xuICAgIGNvbnN0IHsgZmllbGRzLCBlbnRyeSwgZmllbGRzTWV0YURhdGEgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZmllbGQgPSBmaWVsZHMuZmluZChmID0+IGYuZ2V0KCduYW1lJykgPT09IG5hbWUpO1xuICAgIGNvbnN0IG5lc3RlZEZpZWxkcyA9IGZpZWxkICYmIGZpZWxkLmdldCgnZmllbGRzJyk7XG4gICAgY29uc3QgdmFsdWUgPSBlbnRyeS5nZXRJbihbJ2RhdGEnLCBmaWVsZC5nZXQoJ25hbWUnKV0pO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZmllbGRzTWV0YURhdGEuZ2V0KGZpZWxkLmdldCgnbmFtZScpLCBNYXAoKSk7XG5cbiAgICBpZiAoTGlzdC5pc0xpc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKHZhbCA9PiB7XG4gICAgICAgIGNvbnN0IHdpZGdldHMgPVxuICAgICAgICAgIG5lc3RlZEZpZWxkcyAmJlxuICAgICAgICAgIE1hcChcbiAgICAgICAgICAgIG5lc3RlZEZpZWxkcy5tYXAoKGYsIGkpID0+IFtcbiAgICAgICAgICAgICAgZi5nZXQoJ25hbWUnKSxcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9Pnt0aGlzLmdldFdpZGdldChmLCB2YWwsIG1ldGFkYXRhLmdldChmLmdldCgnbmFtZScpKSwgdGhpcy5wcm9wcyl9PC9kaXY+LFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIE1hcCh7IGRhdGE6IHZhbCwgd2lkZ2V0cyB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXAoe1xuICAgICAgZGF0YTogdmFsdWUsXG4gICAgICB3aWRnZXRzOlxuICAgICAgICBuZXN0ZWRGaWVsZHMgJiZcbiAgICAgICAgTWFwKFxuICAgICAgICAgIG5lc3RlZEZpZWxkcy5tYXAoZiA9PiBbXG4gICAgICAgICAgICBmLmdldCgnbmFtZScpLFxuICAgICAgICAgICAgdGhpcy5nZXRXaWRnZXQoZiwgdmFsdWUsIG1ldGFkYXRhLmdldChmLmdldCgnbmFtZScpKSwgdGhpcy5wcm9wcyksXG4gICAgICAgICAgXSksXG4gICAgICAgICksXG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZW50cnksIGNvbGxlY3Rpb24sIGNvbmZpZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghZW50cnkgfHwgIWVudHJ5LmdldCgnZGF0YScpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aWV3Q29tcG9uZW50ID1cbiAgICAgIGdldFByZXZpZXdUZW1wbGF0ZShzZWxlY3RUZW1wbGF0ZU5hbWUoY29sbGVjdGlvbiwgZW50cnkuZ2V0KCdzbHVnJykpKSB8fCBFZGl0b3JQcmV2aWV3O1xuXG4gICAgdGhpcy5pbmZlckZpZWxkcygpO1xuXG4gICAgY29uc3QgcHJldmlld1Byb3BzID0ge1xuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIHdpZGdldEZvcjogdGhpcy53aWRnZXRGb3IsXG4gICAgICB3aWRnZXRzRm9yOiB0aGlzLndpZGdldHNGb3IsXG4gICAgfTtcblxuICAgIGNvbnN0IHN0eWxlRWxzID0gZ2V0UHJldmlld1N0eWxlcygpLm1hcCgoc3R5bGUsIGkpID0+IHtcbiAgICAgIGlmIChzdHlsZS5yYXcpIHtcbiAgICAgICAgcmV0dXJuIDxzdHlsZSBrZXk9e2l9PntzdHlsZS52YWx1ZX08L3N0eWxlPjtcbiAgICAgIH1cbiAgICAgIHJldHVybiA8bGluayBrZXk9e2l9IGhyZWY9e3N0eWxlLnZhbHVlfSB0eXBlPVwidGV4dC9jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgLz47XG4gICAgfSk7XG5cbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIDxQcmV2aWV3UGFuZUZyYW1lIGlkPVwicHJldmlldy1wYW5lXCIgaGVhZD17c3R5bGVFbHN9IC8+O1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxDb250ZW50ID0gYFxuPCFET0NUWVBFIGh0bWw+XG48aHRtbD5cbiAgPGhlYWQ+PGJhc2UgdGFyZ2V0PVwiX2JsYW5rXCIvPjwvaGVhZD5cbiAgPGJvZHk+PGRpdj48L2Rpdj48L2JvZHk+XG48L2h0bWw+XG5gO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxFcnJvckJvdW5kYXJ5IGNvbmZpZz17Y29uZmlnfT5cbiAgICAgICAgPFByZXZpZXdQYW5lRnJhbWUgaWQ9XCJwcmV2aWV3LXBhbmVcIiBoZWFkPXtzdHlsZUVsc30gaW5pdGlhbENvbnRlbnQ9e2luaXRpYWxDb250ZW50fT5cbiAgICAgICAgICA8RnJhbWVDb250ZXh0Q29uc3VtZXI+XG4gICAgICAgICAgICB7KHsgZG9jdW1lbnQsIHdpbmRvdyB9KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEVkaXRvclByZXZpZXdDb250ZW50XG4gICAgICAgICAgICAgICAgICB7Li4ueyBwcmV2aWV3Q29tcG9uZW50LCBwcmV2aWV3UHJvcHM6IHsgLi4ucHJldmlld1Byb3BzLCBkb2N1bWVudCwgd2luZG93IH0gfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L0ZyYW1lQ29udGV4dENvbnN1bWVyPlxuICAgICAgICA8L1ByZXZpZXdQYW5lRnJhbWU+XG4gICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgKTtcbiAgfVxufVxuXG5QcmV2aWV3UGFuZS5wcm9wVHlwZXMgPSB7XG4gIGNvbGxlY3Rpb246IEltbXV0YWJsZVByb3BUeXBlcy5tYXAuaXNSZXF1aXJlZCxcbiAgZmllbGRzOiBJbW11dGFibGVQcm9wVHlwZXMubGlzdC5pc1JlcXVpcmVkLFxuICBlbnRyeTogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxuICBmaWVsZHNNZXRhRGF0YTogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxuICBnZXRBc3NldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuICBjb25zdCBpc0xvYWRpbmdBc3NldCA9IHNlbGVjdElzTG9hZGluZ0Fzc2V0KHN0YXRlLm1lZGlhcyk7XG4gIHJldHVybiB7IGlzTG9hZGluZ0Fzc2V0LCBjb25maWc6IHN0YXRlLmNvbmZpZyB9O1xufVxuXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIHtcbiAgICBib3VuZEdldEFzc2V0OiAoY29sbGVjdGlvbiwgZW50cnkpID0+IGJvdW5kR2V0QXNzZXQoZGlzcGF0Y2gsIGNvbGxlY3Rpb24sIGVudHJ5KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlUHJvcHMsXG4gICAgLi4uZGlzcGF0Y2hQcm9wcyxcbiAgICAuLi5vd25Qcm9wcyxcbiAgICBnZXRBc3NldDogZGlzcGF0Y2hQcm9wcy5ib3VuZEdldEFzc2V0KG93blByb3BzLmNvbGxlY3Rpb24sIG93blByb3BzLmVudHJ5KSxcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykoUHJldmlld1BhbmUpO1xuIl19 */"));

class PreviewPane extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getWidget", (field, value, metadata, props, idx = null) => {
      const {
        getAsset,
        entry
      } = props;
      const widget = (0, _registry.resolveWidget)(field.get('widget'));
      const key = idx ? field.get('name') + '_' + idx : field.get('name');

      const valueIsInMap = value && !widget.allowMapValue && _immutable.Map.isMap(value);
      /**
       * Use an HOC to provide conditional updates for all previews.
       */


      return !widget.preview ? null : (0, _core.jsx)(_PreviewHOC.default, {
        previewComponent: widget.preview,
        key: key,
        field: field,
        getAsset: getAsset,
        value: valueIsInMap ? value.get(field.get('name')) : value,
        entry: entry,
        fieldsMetaData: metadata,
        resolveWidget: _registry.resolveWidget
      });
    });

    _defineProperty(this, "inferedFields", {});

    _defineProperty(this, "widgetFor", (name, fields = this.props.fields, values = this.props.entry.get('data'), fieldsMetaData = this.props.fieldsMetaData) => {
      // We retrieve the field by name so that this function can also be used in
      // custom preview templates, where the field object can't be passed in.
      let field = fields && fields.find(f => f.get('name') === name);
      let value = _immutable.Map.isMap(values) && values.get(field.get('name'));

      if (field.get('meta')) {
        value = this.props.entry.getIn(['meta', field.get('name')]);
      }

      const nestedFields = field.get('fields');
      const singleField = field.get('field');
      const metadata = fieldsMetaData && fieldsMetaData.get(field.get('name'), (0, _immutable.Map)());

      if (nestedFields) {
        field = field.set('fields', this.getNestedWidgets(nestedFields, value, metadata));
      }

      if (singleField) {
        field = field.set('field', this.getSingleNested(singleField, value, metadata));
      }

      const labelledWidgets = ['string', 'text', 'number'];
      const inferedField = Object.entries(this.inferedFields).filter(([key]) => {
        const fieldToMatch = (0, _collections.selectField)(this.props.collection, key);
        return fieldToMatch === field;
      }).map(([, value]) => value)[0];

      if (inferedField) {
        value = inferedField.defaultPreview(value);
      } else if (value && labelledWidgets.indexOf(field.get('widget')) !== -1 && value.toString().length < 50) {
        value = (0, _core.jsx)("div", null, (0, _core.jsx)("strong", null, field.get('label', field.get('name')), ":"), " ", value);
      }

      return value ? this.getWidget(field, value, metadata, this.props) : null;
    });

    _defineProperty(this, "getNestedWidgets", (fields, values, fieldsMetaData) => {
      // Fields nested within a list field will be paired with a List of value Maps.
      if (_immutable.List.isList(values)) {
        return values.map(value => this.widgetsForNestedFields(fields, value, fieldsMetaData));
      } // Fields nested within an object field will be paired with a single Map of values.


      return this.widgetsForNestedFields(fields, values, fieldsMetaData);
    });

    _defineProperty(this, "getSingleNested", (field, values, fieldsMetaData) => {
      if (_immutable.List.isList(values)) {
        return values.map((value, idx) => this.getWidget(field, value, fieldsMetaData.get(field.get('name')), this.props, idx));
      }

      return this.getWidget(field, values, fieldsMetaData.get(field.get('name')), this.props);
    });

    _defineProperty(this, "widgetsForNestedFields", (fields, values, fieldsMetaData) => {
      return fields.map(field => this.widgetFor(field.get('name'), fields, values, fieldsMetaData));
    });

    _defineProperty(this, "widgetsFor", name => {
      const {
        fields,
        entry,
        fieldsMetaData
      } = this.props;
      const field = fields.find(f => f.get('name') === name);
      const nestedFields = field && field.get('fields');
      const value = entry.getIn(['data', field.get('name')]);
      const metadata = fieldsMetaData.get(field.get('name'), (0, _immutable.Map)());

      if (_immutable.List.isList(value)) {
        return value.map(val => {
          const widgets = nestedFields && (0, _immutable.Map)(nestedFields.map((f, i) => [f.get('name'), (0, _core.jsx)("div", {
            key: i
          }, this.getWidget(f, val, metadata.get(f.get('name')), this.props))]));
          return (0, _immutable.Map)({
            data: val,
            widgets
          });
        });
      }

      return (0, _immutable.Map)({
        data: value,
        widgets: nestedFields && (0, _immutable.Map)(nestedFields.map(f => [f.get('name'), this.getWidget(f, value, metadata.get(f.get('name')), this.props)]))
      });
    });
  }

  inferFields() {
    const titleField = (0, _collections.selectInferedField)(this.props.collection, 'title');
    const shortTitleField = (0, _collections.selectInferedField)(this.props.collection, 'shortTitle');
    const authorField = (0, _collections.selectInferedField)(this.props.collection, 'author');
    this.inferedFields = {};
    if (titleField) this.inferedFields[titleField] = _fieldInference.INFERABLE_FIELDS.title;
    if (shortTitleField) this.inferedFields[shortTitleField] = _fieldInference.INFERABLE_FIELDS.shortTitle;
    if (authorField) this.inferedFields[authorField] = _fieldInference.INFERABLE_FIELDS.author;
  }
  /**
   * Returns the widget component for a named field, and makes recursive calls
   * to retrieve components for nested and deeply nested fields, which occur in
   * object and list type fields. Used internally to retrieve widgets, and also
   * exposed for use in custom preview templates.
   */


  render() {
    const {
      entry,
      collection,
      config
    } = this.props;

    if (!entry || !entry.get('data')) {
      return null;
    }

    const previewComponent = (0, _registry.getPreviewTemplate)((0, _collections.selectTemplateName)(collection, entry.get('slug'))) || _EditorPreview.default;

    this.inferFields();

    const previewProps = _objectSpread(_objectSpread({}, this.props), {}, {
      widgetFor: this.widgetFor,
      widgetsFor: this.widgetsFor
    });

    const styleEls = (0, _registry.getPreviewStyles)().map((style, i) => {
      if (style.raw) {
        return (0, _core.jsx)("style", {
          key: i
        }, style.value);
      }

      return (0, _core.jsx)("link", {
        key: i,
        href: style.value,
        type: "text/css",
        rel: "stylesheet"
      });
    });

    if (!collection) {
      (0, _core.jsx)(PreviewPaneFrame, {
        id: "preview-pane",
        head: styleEls
      });
    }

    const initialContent = `
<!DOCTYPE html>
<html>
  <head><base target="_blank"/></head>
  <body><div></div></body>
</html>
`;
    return (0, _core.jsx)(_UI.ErrorBoundary, {
      config: config
    }, (0, _core.jsx)(PreviewPaneFrame, {
      id: "preview-pane",
      head: styleEls,
      initialContent: initialContent
    }, (0, _core.jsx)(_reactFrameComponent.FrameContextConsumer, null, ({
      document,
      window
    }) => {
      return (0, _core.jsx)(_EditorPreviewContent.default, {
        previewComponent,
        previewProps: _objectSpread(_objectSpread({}, previewProps), {}, {
          document,
          window
        })
      });
    })));
  }

}

exports.PreviewPane = PreviewPane;
PreviewPane.propTypes = {
  collection: _reactImmutableProptypes.default.map.isRequired,
  fields: _reactImmutableProptypes.default.list.isRequired,
  entry: _reactImmutableProptypes.default.map.isRequired,
  fieldsMetaData: _reactImmutableProptypes.default.map.isRequired,
  getAsset: _propTypes.default.func.isRequired
};

function mapStateToProps(state) {
  const isLoadingAsset = (0, _medias.selectIsLoadingAsset)(state.medias);
  return {
    isLoadingAsset,
    config: state.config
  };
}

function mapDispatchToProps(dispatch) {
  return {
    boundGetAsset: (collection, entry) => (0, _media.boundGetAsset)(dispatch, collection, entry)
  };
}

function mergeProps(stateProps, dispatchProps, ownProps) {
  return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, stateProps), dispatchProps), ownProps), {}, {
    getAsset: dispatchProps.boundGetAsset(ownProps.collection, ownProps.entry)
  });
}

var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps, mergeProps)(PreviewPane);

exports.default = _default;